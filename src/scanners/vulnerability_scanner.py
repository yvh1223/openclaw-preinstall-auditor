"""
Vulnerability Scanner - Detects known CVEs and architectural security weaknesses
specific to OpenClaw/Clawdbot/Moltbot based on published security research.

Sources:
- CVE-2026-25253: 1-Click RCE via auth token exfiltration (depthfirst/Mav Levin)
- Enterprise security advisory (Feb 2026): ClawHavoc campaign, ~900 malicious skills
- Independent researcher @theonejvo: Exposed control UIs, localhost auto-approve bypass
- Enterprise vulnerability management advisory: Agentic AI security mitigations
- Reddit r/cybersecurity: ClawHub marketplace trust manipulation
- HiddenLayer: Indirect prompt injection risks in AI assistants
"""

import re
import os
from pathlib import Path
from typing import List, Dict, Any


class VulnerabilityScanner:
    """Scans for known OpenClaw/Clawdbot CVEs and architectural weaknesses."""

    def __init__(self, repo_path: str):
        self.repo_path = Path(repo_path)
        self.findings: List[Dict[str, Any]] = []

    def scan(self) -> List[Dict[str, Any]]:
        """Run all vulnerability checks."""
        self.findings = []
        self._check_cve_2026_25253()
        self._check_cve_2025_59466()
        self._check_cve_2026_21636()
        self._check_ghsa_lobster_path_injection()
        self._check_localhost_auto_approve()
        self._check_trusted_proxy_defaults()
        self._check_plaintext_credentials()
        self._check_dangerous_config_flags()
        self._check_exec_approval_bypass()
        self._check_soul_md_exposure()
        self._check_websocket_origin_validation()
        self._check_container_security()
        self._check_auth_token_storage()
        self._check_marketplace_trust()
        self._check_npm_lifecycle_scripts()
        return self.findings

    def _read_file(self, rel_path: str) -> str | None:
        """Read a file relative to repo root, return content or None."""
        fpath = self.repo_path / rel_path
        if fpath.exists():
            try:
                return fpath.read_text(encoding="utf-8", errors="ignore")
            except OSError:
                pass
        return None

    def _search_files(self, pattern: str, paths: list[str]) -> list[dict]:
        """Search for regex pattern in specific files."""
        results = []
        for rel_path in paths:
            content = self._read_file(rel_path)
            if content is None:
                continue
            for match in re.finditer(pattern, content, re.IGNORECASE):
                line_num = content[:match.start()].count("\n") + 1
                results.append({
                    "file": rel_path,
                    "line": line_num,
                    "match": match.group(0)[:200],
                })
        return results

    def _parse_version_tuple(self, value: str) -> tuple[int, int, int] | None:
        """Parse a semantic-ish version string into a comparable tuple."""
        match = re.search(r"(\d+)(?:\.(\d+))?(?:\.(\d+))?", value)
        if not match:
            return None
        major = int(match.group(1))
        minor = int(match.group(2) or 0)
        patch = int(match.group(3) or 0)
        return (major, minor, patch)

    def _node_requirement_allows_vulnerable(
        self,
        requirement: str,
        minimum_safe: tuple[int, int, int] = (22, 12, 0),
    ) -> bool:
        """
        Return True if the Node.js requirement may allow versions below
        minimum_safe.
        """
        req = requirement.strip()
        if not req:
            return True
        branches = [part.strip() for part in req.split("||") if part.strip()]
        if not branches:
            return True
        return any(
            self._node_branch_allows_vulnerable(branch, minimum_safe)
            for branch in branches
        )

    def _node_branch_allows_vulnerable(
        self,
        branch: str,
        minimum_safe: tuple[int, int, int],
    ) -> bool:
        """Evaluate one Node.js version branch for vulnerable-version allowance."""
        text = branch.strip()
        if not text:
            return True

        wildcard_match = re.search(r"(\d+)\s*\.\s*[xX*]", text)
        if wildcard_match:
            return (int(wildcard_match.group(1)), 0, 0) < minimum_safe
        if text in {"*", "latest"}:
            return True

        comparators = re.findall(
            r"([~^]|<=|>=|<|>|=)?\s*v?(\d+(?:\.\d+){0,2})",
            text,
        )
        if not comparators:
            return True

        exact_version: tuple[int, int, int] | None = None
        lower_bound: tuple[int, int, int] | None = None

        for op, raw_ver in comparators:
            version = self._parse_version_tuple(raw_ver)
            if version is None:
                continue
            operator = op or "="

            if operator in {"=", ""}:
                exact_version = version
            elif operator in {"^", "~", ">=", ">"}:
                if lower_bound is None or version > lower_bound:
                    lower_bound = version
            elif operator in {"<", "<="}:
                if version <= minimum_safe:
                    return True

        if exact_version is not None:
            return exact_version < minimum_safe
        if lower_bound is None:
            return True
        return lower_bound < minimum_safe

    def _get_node_engine_requirement(self) -> str:
        """Read and return package.json engines.node requirement if available."""
        pkg = self._read_file("package.json")
        if not pkg:
            return ""
        import json
        try:
            data = json.loads(pkg)
        except json.JSONDecodeError:
            return ""
        engines = data.get("engines", {})
        return str(engines.get("node", "")).strip()

    # ----------------------------------------------------------------
    # CVE-2026-25253: 1-Click RCE via gatewayUrl parameter
    #
    # CVSS 8.8 | CWE-669 (Incorrect Resource Transfer Between Spheres)
    # Discovered by: Mav Levin (depthfirst)
    # Fixed in: v2026.1.29 (Jan 30, 2026)
    # NVD: https://nvd.nist.gov/vuln/detail/CVE-2026-25253
    #
    # The Control UI accepts a gatewayUrl query parameter and auto-connects
    # a WebSocket to that URL, transmitting the user's auth token. An
    # attacker crafts a malicious link, steals the token, then uses it to
    # disable sandbox + exec approvals and execute arbitrary commands.
    # ----------------------------------------------------------------
    def _check_cve_2026_25253(self):
        """Check for CVE-2026-25253 (1-Click RCE via gatewayUrl)."""
        ui_settings = self._read_file("ui/src/ui/app-settings.ts")
        if ui_settings and 'params.get("gatewayUrl")' in ui_settings:
            # The fix adds a confirmation modal (pendingGatewayUrl + user prompt)
            has_pending = "pendingGatewayUrl" in ui_settings
            has_confirm = "confirm" in ui_settings.lower() or "modal" in ui_settings.lower()

            if has_pending and not has_confirm:
                severity = "critical"
                desc = (
                    "CVE-2026-25253 (CVSS 8.8): gatewayUrl accepted from URL parameters "
                    "without explicit user confirmation modal. An attacker can craft a "
                    "link like ?gatewayUrl=attacker.com/ws to exfiltrate auth tokens over "
                    "WebSocket, then chain to full RCE by disabling sandbox and exec "
                    "approvals. Reason: The UI auto-connects to the supplied gateway URL "
                    "transmitting credentials without user consent."
                )
            else:
                severity = "high"
                desc = (
                    "CVE-2026-25253 (CVSS 8.8): gatewayUrl parameter handling detected. "
                    "The patched version uses pendingGatewayUrl with user confirmation. "
                    "Verify this instance is running v2026.1.29+ with the confirmation "
                    "modal active. Reason: Even patched versions retain the attack surface "
                    "- the parameter is still accepted from URLs."
                )

            self.findings.append({
                "type": "vulnerability",
                "category": "cve",
                "severity": severity,
                "title": "CVE-2026-25253: gatewayUrl token exfiltration",
                "description": desc,
                "cve": "CVE-2026-25253",
                "cvss": 8.8,
                "file": "ui/src/ui/app-settings.ts",
                "reason": "NVD-listed CVE discovered by depthfirst (Mav Levin), fixed in v2026.1.29",
                "references": ["https://nvd.nist.gov/vuln/detail/CVE-2026-25253"],
            })

        # gatewayUrl persistence in localStorage
        storage = self._read_file("ui/src/ui/storage.ts")
        if storage and "gatewayUrl" in storage:
            self.findings.append({
                "type": "vulnerability",
                "category": "cve",
                "severity": "medium",
                "title": "CVE-2026-25253: gatewayUrl persisted in localStorage",
                "description": (
                    "gatewayUrl is stored in localStorage. If an attacker's URL is "
                    "written here via the CVE-2026-25253 vector, it persists across "
                    "sessions until manually cleared. Reason: Persistent storage of "
                    "attacker-controlled gateway URL enables session-surviving attacks."
                ),
                "cve": "CVE-2026-25253",
                "file": "ui/src/ui/storage.ts",
                "references": ["https://nvd.nist.gov/vuln/detail/CVE-2026-25253"],
            })

    # ----------------------------------------------------------------
    # Localhost auto-approve bypass
    #
    # Discovered by: @theonejvo (independent security researcher)
    # Source: https://x.com/theonejvo/status/2015401219746128322
    #
    # Clawdbot's device pairing auto-approves connections from localhost
    # without authentication. When behind a reverse proxy (nginx, Caddy),
    # ALL connections arrive from 127.0.0.1, so ALL connections are
    # auto-approved. @theonejvo found hundreds of exposed instances via
    # Shodan with full credential access and command execution.
    # ----------------------------------------------------------------
    def _check_localhost_auto_approve(self):
        """Check for localhost auto-approve bypass."""
        handler_path = "src/gateway/server/ws-connection/message-handler.ts"
        content = self._read_file(handler_path)
        if content is None:
            return

        if re.search(r"silent\s*:\s*isLocalClient", content):
            line_matches = self._search_files(r"silent\s*:\s*isLocalClient", [handler_path])
            line_num = line_matches[0]["line"] if line_matches else 0

            self.findings.append({
                "type": "vulnerability",
                "category": "auth_bypass",
                "severity": "critical",
                "title": "Localhost auto-approve bypasses authentication",
                "description": (
                    "Device pairing is auto-approved (silent: isLocalClient) for "
                    "connections from localhost. When deployed behind a reverse proxy "
                    "(nginx, Caddy), ALL connections arrive from 127.0.0.1, causing "
                    "every connection to be auto-approved without authentication. "
                    "Reason: Independent researcher found hundreds of exposed instances "
                    "on Shodan with this misconfiguration, giving full credential "
                    "access and command execution to unauthenticated users."
                ),
                "file": handler_path,
                "line": line_num,
                "references": ["https://owasp.org/www-project-web-security-testing-guide/"],
            })

        if "auto-approved" in content:
            self.findings.append({
                "type": "vulnerability",
                "category": "auth_bypass",
                "severity": "medium",
                "title": "Auto-approved device pairing logging detected",
                "description": (
                    "Log message for auto-approved device pairing found. Confirms "
                    "that silent auto-approval is actively implemented. Reason: "
                    "Logging confirms the auto-approve code path is reachable."
                ),
                "file": handler_path,
                "references": ["https://owasp.org/www-project-web-security-testing-guide/"],
            })

    # ----------------------------------------------------------------
    # Trusted proxy default configuration
    #
    # Source: @theonejvo research + OpenClaw source code analysis
    #
    # trustedProxies defaults to empty. When empty, X-Forwarded-For
    # headers are ignored and the raw socket address is used. Behind
    # a proxy this is always 127.0.0.1, triggering localhost auto-approve.
    # ----------------------------------------------------------------
    def _check_trusted_proxy_defaults(self):
        """Check trustedProxies configuration defaults."""
        net_path = "src/gateway/net.ts"
        content = self._read_file(net_path)
        if content is None:
            return

        if re.search(r"trustedProxies\?\s*:\s*string\[\]", content) or \
           re.search(r"!trustedProxies\s*\|\|\s*trustedProxies\.length\s*===\s*0", content):
            self.findings.append({
                "type": "vulnerability",
                "category": "config_weakness",
                "severity": "high",
                "title": "trustedProxies defaults to empty - proxy auth bypass risk",
                "description": (
                    "trustedProxies configuration defaults to empty. When empty, the "
                    "gateway ignores X-Forwarded-For headers and uses the raw socket "
                    "address. Behind a reverse proxy, this means all connections appear "
                    "as localhost and receive auto-approved auth. Reason: This is a "
                    "classic proxy misconfiguration pattern (OWASP) that converts the "
                    "localhost auto-approve into a full auth bypass for internet-facing "
                    "deployments."
                ),
                "file": net_path,
                "references": ["https://owasp.org/www-project-web-security-testing-guide/"],
            })

    # ----------------------------------------------------------------
    # Plaintext credential storage
    #
    # Source: @theonejvo research (found plaintext API keys, tokens,
    # OAuth secrets in exposed instances) + Reddit r/cybersecurity
    # discussions about credential leakage risk.
    # ----------------------------------------------------------------
    def _check_plaintext_credentials(self):
        """Check for plaintext storage of sensitive credentials."""
        env_example = self._read_file(".env.example")
        if env_example:
            cred_patterns = re.findall(
                r"(TWILIO_AUTH_TOKEN|API_KEY|SECRET|PASSWORD|TOKEN)\s*=",
                env_example, re.IGNORECASE,
            )
            if cred_patterns:
                self.findings.append({
                    "type": "vulnerability",
                    "category": "credential_storage",
                    "severity": "medium",
                    "title": "Credential template in .env.example",
                    "description": (
                        f"Credential fields found in .env.example: "
                        f"{', '.join(set(cred_patterns))}. Users copy this to .env "
                        "with real values stored in plaintext on disk. Reason: "
                        "Exposed instances showed Anthropic API keys, Telegram bot "
                        "tokens, Slack OAuth credentials all readable in plaintext."
                    ),
                    "file": ".env.example",
                    "references": ["https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/"],
                })

        # Gateway tokens in deployment files
        docker_files = [
            "docker-setup.sh", "docker-compose.yml",
            "Dockerfile", "scripts/sandbox-common-setup.sh",
        ]
        for f in docker_files:
            content = self._read_file(f)
            if content and re.search(r"OPENCLAW_GATEWAY_TOKEN|OPENCLAW_GATEWAY_PASSWORD", content):
                self.findings.append({
                    "type": "vulnerability",
                    "category": "credential_storage",
                    "severity": "medium",
                    "title": f"Gateway credentials in {f}",
                    "description": (
                        "Gateway authentication tokens/passwords referenced in "
                        f"deployment file {f}. Reason: Secrets in deployment scripts "
                        "are committed to version control and readable by anyone "
                        "with repo access. Use a secrets manager instead."
                    ),
                    "file": f,
                    "references": ["https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/"],
                })

    # ----------------------------------------------------------------
    # Dangerous configuration flags
    # ----------------------------------------------------------------
    def _check_dangerous_config_flags(self):
        """Check for configuration options that weaken security."""
        config_files = [
            "src/config/types.gateway.ts",
            "src/gateway/auth.ts",
        ]

        dangerous_flags = [
            {
                # This flag completely disables device authentication.
                # Reason: If enabled (even accidentally), any WebSocket
                # connection is accepted without cryptographic identity
                # verification, allowing unauthenticated control access.
                "pattern": r"dangerouslyDisableDeviceAuth",
                "title": "dangerouslyDisableDeviceAuth flag exists",
                "severity": "high",
                "desc": (
                    "Configuration flag to completely disable device authentication. "
                    "If enabled, any WebSocket connection is accepted without identity "
                    "verification. Reason: Labeled 'break-glass only' but its existence "
                    "means a single config change removes all auth. Exposed instances "
                    "showed this was sometimes enabled in production."
                ),
            },
            {
                # This flag allows token auth over HTTP (no TLS).
                # Reason: Tokens sent in plaintext can be intercepted by
                # anyone on the network path (MITM, shared WiFi, etc.)
                "pattern": r"allowInsecureAuth",
                "title": "allowInsecureAuth flag exists",
                "severity": "high",
                "desc": (
                    "Flag to allow token-only authentication over unencrypted HTTP. "
                    "Reason: Tokens sent over HTTP can be intercepted via MITM attacks "
                    "on shared networks. Combined with operator.admin scope, intercepted "
                    "tokens give full system control."
                ),
            },
        ]

        for flag in dangerous_flags:
            for f in config_files:
                content = self._read_file(f)
                if content and re.search(flag["pattern"], content):
                    matches = self._search_files(flag["pattern"], [f])
                    line_num = matches[0]["line"] if matches else 0
                    self.findings.append({
                        "type": "vulnerability",
                        "category": "dangerous_config",
                        "severity": flag["severity"],
                        "title": flag["title"],
                        "description": flag["desc"],
                        "file": f,
                        "line": line_num,
                        "references": ["https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/"],
                    })
                    break

    # ----------------------------------------------------------------
    # Exec approval bypass (part of CVE-2026-25253 exploit chain)
    #
    # The full exploit chain:
    # 1. Steal auth token via gatewayUrl parameter
    # 2. Call exec.approvals.set(ask: "off") to disable confirmations
    # 3. Call config.patch(tools.exec.host: "local") to escape sandbox
    # 4. Call node.invoke to execute arbitrary shell commands
    # ----------------------------------------------------------------
    def _check_exec_approval_bypass(self):
        """Check for exec approval bypass mechanisms."""
        exec_path = "src/agents/bash-tools.exec.ts"
        content = self._read_file(exec_path)
        if content is None:
            return

        if re.search(r'ask\s*=\s*["\']off["\']', content):
            matches = self._search_files(r'ask\s*=\s*["\']off["\']', [exec_path])
            line_num = matches[0]["line"] if matches else 0
            self.findings.append({
                "type": "vulnerability",
                "category": "approval_bypass",
                "severity": "critical",
                "title": "Exec approval bypass: ask='off' in elevated mode",
                "description": (
                    "In elevated/full mode, execution approvals can be set to 'off', "
                    "bypassing all user confirmation for shell commands. Reason: This "
                    "is step 2 of the CVE-2026-25253 exploit chain - after stealing "
                    "an auth token, attacker calls exec.approvals.set to disable all "
                    "confirmation prompts before executing arbitrary commands."
                ),
                "file": exec_path,
                "line": line_num,
                "cve": "CVE-2026-25253",
                "references": ["https://nvd.nist.gov/vuln/detail/CVE-2026-25253"],
            })

        if re.search(r"tools\.exec\.host", content):
            self.findings.append({
                "type": "vulnerability",
                "category": "sandbox_escape",
                "severity": "high",
                "title": "Host execution mode configurable at runtime",
                "description": (
                    "tools.exec.host can be changed from 'sandbox' to host execution "
                    "at runtime via config.patch API. Reason: This is step 3 of the "
                    "CVE-2026-25253 exploit chain - attacker switches execution from "
                    "Docker sandbox to host machine, then runs arbitrary commands with "
                    "the host user's full privileges."
                ),
                "file": exec_path,
                "references": ["https://nvd.nist.gov/vuln/detail/CVE-2026-25253"],
            })

        approvals_path = "src/gateway/server-methods/exec-approvals.ts"
        content2 = self._read_file(approvals_path)
        if content2 and "exec.approvals.set" in content2:
            self.findings.append({
                "type": "vulnerability",
                "category": "approval_bypass",
                "severity": "high",
                "title": "exec.approvals.set API endpoint exists",
                "description": (
                    "API endpoint exec.approvals.set allows programmatic control "
                    "of execution approval settings. Reason: With operator.approvals "
                    "scope (granted by default to operator role), approvals can be "
                    "turned off entirely via a single API call."
                ),
                "file": approvals_path,
                "references": ["https://nvd.nist.gov/vuln/detail/CVE-2026-25253"],
            })

    # ----------------------------------------------------------------
    # SOUL.md exposure
    #
    # Source: @theonejvo demonstrated reading SOUL.md via the agent's
    # command execution to understand the agent's full configuration.
    # ----------------------------------------------------------------
    def _check_soul_md_exposure(self):
        """Check for Soul.md persona file handling."""
        workspace_path = "src/agents/workspace.ts"
        content = self._read_file(workspace_path)
        if content and "SOUL.md" in content:
            self.findings.append({
                "type": "vulnerability",
                "category": "information_disclosure",
                "severity": "medium",
                "title": "SOUL.md system prompt file readable via agent",
                "description": (
                    "SOUL.md defines the agent's persona, instructions, and behavioral "
                    "guidelines. Reason: An attacker with control access can 'cat SOUL.md' "
                    "to understand the agent's full configuration, enabled capabilities, "
                    "and operator instructions, as demonstrated in published research."
                ),
                "file": workspace_path,
                "references": ["https://owasp.org/www-project-top-10-for-large-language-model-applications/"],
            })

        evil_path = "src/hooks/soul-evil.ts"
        content2 = self._read_file(evil_path)
        if content2:
            self.findings.append({
                "type": "vulnerability",
                "category": "backdoor",
                "severity": "high",
                "title": "SOUL_EVIL.md swap hook exists in codebase",
                "description": (
                    "Hook file soul-evil.ts can swap SOUL.md with SOUL_EVIL.md "
                    "during 'purge windows'. Reason: This mechanism can replace the "
                    "agent's persona with a malicious one, altering its behavior "
                    "without the operator's knowledge."
                ),
                "file": evil_path,
                "references": ["https://atlas.mitre.org/techniques/AML.T0051"],
            })

    # ----------------------------------------------------------------
    # WebSocket origin validation
    # ----------------------------------------------------------------
    def _check_websocket_origin_validation(self):
        """Check WebSocket origin header validation completeness."""
        origin_path = "src/gateway/origin-check.ts"
        content = self._read_file(origin_path)
        if content is None:
            return

        if re.search(r"loopback|localhost|127\.0\.0\.1", content):
            self.findings.append({
                "type": "vulnerability",
                "category": "websocket_security",
                "severity": "medium",
                "title": "WebSocket origin check allows loopback bypass",
                "description": (
                    "Origin validation includes loopback/localhost exceptions. "
                    "Reason: Combined with CVE-2026-25253, a malicious website can "
                    "perform Cross-Site WebSocket Hijacking (CSWSH) by connecting "
                    "to ws://localhost:18789 from the victim's browser, since the "
                    "origin check passes for loopback addresses."
                ),
                "file": origin_path,
                "references": ["https://owasp.org/www-community/attacks/Cross-Site_Request_Forgery_(CSRF)", "https://nvd.nist.gov/vuln/detail/CVE-2026-25253"],
            })

    # ----------------------------------------------------------------
    # Container security
    #
    # Source: @theonejvo found instances running as root with no
    # privilege separation. The 'whoami' command returned 'root'.
    # ----------------------------------------------------------------
    def _check_container_security(self):
        """Check Docker container security configuration."""
        dockerfile = self._read_file("Dockerfile")
        if dockerfile is None:
            return

        if not re.search(r"USER\s+(?!root)\w+", dockerfile):
            if "USER root" in dockerfile or "USER" not in dockerfile:
                self.findings.append({
                    "type": "vulnerability",
                    "category": "container_security",
                    "severity": "high",
                    "title": "Docker container may run as root",
                    "description": (
                        "Dockerfile does not set a non-root USER. Reason: Published "
                        "research showed deployed instances running as root with no "
                        "privilege separation - 'whoami' returned root, giving command "
                        "execution full system access."
                    ),
                    "file": "Dockerfile",
                    "references": ["https://owasp.org/www-project-docker-security/"],
                })

        if re.search(r"--privileged|--cap-add|SYS_ADMIN", dockerfile):
            self.findings.append({
                "type": "vulnerability",
                "category": "container_security",
                "severity": "critical",
                "title": "Privileged container execution",
                "description": (
                    "Container runs with elevated privileges. Reason: Privileged "
                    "containers can escape Docker isolation, making the sandbox "
                    "ineffective as a security boundary."
                ),
                "file": "Dockerfile",
                "references": ["https://owasp.org/www-project-docker-security/"],
            })

    # ----------------------------------------------------------------
    # Auth token storage and scope escalation
    #
    # Source: CVE-2026-25253 research (depthfirst) showed that stolen
    # tokens get operator.admin scope by default, granting full control.
    # ----------------------------------------------------------------
    def _check_auth_token_storage(self):
        """Check how auth tokens are stored and managed."""
        methods_path = "src/gateway/server-methods.ts"
        content = self._read_file(methods_path)
        if content:
            if re.search(r'operator\.admin', content):
                self.findings.append({
                    "type": "vulnerability",
                    "category": "privilege_escalation",
                    "severity": "high",
                    "title": "operator.admin scope grants full control",
                    "description": (
                        "The operator.admin scope grants unrestricted access to all "
                        "gateway functions including config changes, exec approvals, "
                        "conversation history, and credential access. Reason: Per "
                        "CVE-2026-25253, the default operator role gets operator.admin "
                        "automatically, meaning any stolen token gives complete control."
                    ),
                    "file": methods_path,
                    "cve": "CVE-2026-25253",
                    "references": ["https://nvd.nist.gov/vuln/detail/CVE-2026-25253"],
                })

        handler_path = "src/gateway/server/ws-connection/message-handler.ts"
        content2 = self._read_file(handler_path)
        if content2 and re.search(r'role\s*===\s*["\']operator["\'].*operator\.admin', content2, re.DOTALL):
            self.findings.append({
                "type": "vulnerability",
                "category": "privilege_escalation",
                "severity": "high",
                "title": "Operator role auto-assigned operator.admin scope",
                "description": (
                    "When no specific scopes are requested, operator role connections "
                    "automatically receive operator.admin scope. Reason: This means "
                    "every authenticated operator connection gets full administrative "
                    "access by default, violating the principle of least privilege."
                ),
                "file": handler_path,
                "references": ["https://nvd.nist.gov/vuln/detail/CVE-2026-25253"],
            })

    # ----------------------------------------------------------------
    # ClawHub marketplace trust manipulation
    #
    # Source: Reddit r/cybersecurity thread discussing how attackers
    # game the ClawHub trust system with fake downloads to make
    # malicious skills appear popular and trustworthy.
    # Also: eSecurity Planet report on 341+ malicious skills found.
    # ----------------------------------------------------------------
    def _check_marketplace_trust(self):
        """
        Check for marketplace trust/download count mechanisms that could
        be manipulated. Skills that become '#1 most downloaded' via fake
        metrics trick users into installing malware.
        """
        # Check if there's a skills registry or download tracking system
        skill_paths = [
            "src/skills",
            "src/clawhub",
            "src/marketplace",
            "src/registry",
        ]

        for rel_dir in skill_paths:
            dir_path = self.repo_path / rel_dir
            if dir_path.exists():
                self.findings.append({
                    "type": "vulnerability",
                    "category": "supply_chain",
                    "severity": "high",
                    "title": f"Skills marketplace component: {rel_dir}",
                    "description": (
                        f"Skills marketplace/registry found at {rel_dir}. Reason: "
                        "Published research showed attackers manipulating ClawHub "
                        "download counters with unauthenticated requests, making "
                        "malicious skills appear as '#1 most downloaded'. ~341 "
                        "malicious skills were identified distributing credential "
                        "stealers and backdoors via this vector."
                    ),
                    "file": rel_dir,
                    "references": ["https://attack.mitre.org/techniques/T1195/002/"],
                })

        # Check for skill installation mechanisms that could be exploited
        install_files = [
            "src/skills/install.ts",
            "src/skills/skill-loader.ts",
            "src/skills/skill-manager.ts",
        ]
        for f in install_files:
            content = self._read_file(f)
            if content:
                # Check if skills can run arbitrary code during install
                if re.search(r"exec|spawn|shell|child_process", content, re.IGNORECASE):
                    self.findings.append({
                        "type": "vulnerability",
                        "category": "supply_chain",
                        "severity": "high",
                        "title": f"Skill install executes code: {f}",
                        "description": (
                            f"Skill installation in {f} includes code execution "
                            "capabilities. Reason: Malicious skills use install-time "
                            "exploitation to create encrypted tunnels and backdoors "
                            "during skill setup, mimicking system maintenance traffic."
                        ),
                        "file": f,
                        "references": ["https://attack.mitre.org/techniques/T1195/002/"],
                    })

    def _check_cve_2025_59466(self):
        """
        CVE-2025-59466: async_hooks Denial-of-Service in Node.js.

        Why: Affects Node.js < 22.12.0. OpenClaw requires this minimum
        version. A malicious skill could trigger async_hooks to crash
        the agent process, creating a denial-of-service condition.
        Found in OpenClaw's SECURITY.md.
        """
        # Check package.json for Node.js engine version requirement
        node_req = self._get_node_engine_requirement()
        if node_req and self._node_requirement_allows_vulnerable(node_req):
            self.findings.append({
                "type": "vulnerability",
                "category": "dependency_cve",
                "severity": "high",
                "title": "CVE-2025-59466: Node.js async_hooks DoS",
                "description": (
                    f"Node.js engine requirement '{node_req}' may allow "
                    "versions vulnerable to CVE-2025-59466 (async_hooks DoS). "
                    "Versions below 22.12.0 are affected."
                ),
                "file": "package.json",
                "cve": "CVE-2025-59466",
                "reason": "Documented in OpenClaw SECURITY.md; malicious skills can trigger async_hooks crash",
                "references": ["https://nvd.nist.gov/vuln/detail/CVE-2025-59466"],
            })

    def _check_cve_2026_21636(self):
        """
        CVE-2026-21636: Node.js Permission Model Bypass.

        Why: Affects Node.js < 22.12.0. This is critically important because
        OpenClaw relies on the Node.js permission model to sandbox agent tool
        execution. A bypass means malicious skills can escape their sandbox
        entirely. Found in OpenClaw's SECURITY.md.
        """
        node_req = self._get_node_engine_requirement()
        allows_vulnerable_node = self._node_requirement_allows_vulnerable(node_req) if node_req else True

        # Check for permission model usage that could be bypassed
        permission_files = [
            "src/agents/permissions.ts",
            "src/security/sandbox.ts",
            "src/gateway/server/permissions.ts",
        ]
        for f in permission_files:
            content = self._read_file(f)
            if content:
                if re.search(r"--experimental-permission|process\.permission|Permission\s*Model", content, re.IGNORECASE):
                    severity = "critical" if allows_vulnerable_node else "medium"
                    if allows_vulnerable_node:
                        desc = (
                            f"File {f} relies on Node.js Permission Model for sandboxing. "
                            "CVE-2026-21636 allows bypassing this model in Node.js < 22.12.0. "
                            f"Current engine requirement '{node_req or 'unknown'}' may allow vulnerable versions."
                        )
                    else:
                        desc = (
                            f"File {f} relies on Node.js Permission Model for sandboxing. "
                            f"Engine requirement '{node_req}' appears to enforce >=22.12.0, "
                            "but runtime Node.js should still be verified during deployment."
                        )

                    self.findings.append({
                        "type": "vulnerability",
                        "category": "sandbox_escape",
                        "severity": severity,
                        "title": "CVE-2026-21636: Node.js Permission Model bypass risk",
                        "description": desc,
                        "file": f,
                        "cve": "CVE-2026-21636",
                        "reason": "OpenClaw uses Node.js Permission Model for sandboxing; bypass means full skill escape",
                        "references": ["https://nvd.nist.gov/vuln/detail/CVE-2026-21636"],
                    })

        # Also flag in SECURITY.md if it documents the requirement
        security_md = self._read_file("SECURITY.md")
        if security_md and "CVE-2026-21636" in security_md:
            self.findings.append({
                "type": "vulnerability",
                "category": "sandbox_escape",
                "severity": "high" if allows_vulnerable_node else "info",
                "title": "CVE-2026-21636: Permission Model bypass documented",
                "description": (
                    "SECURITY.md documents CVE-2026-21636 (Node.js Permission Model bypass). "
                    f"Engine requirement is '{node_req or 'unknown'}'. "
                    "Users running Node.js < 22.12.0 have no effective sandbox. "
                    "Pre-install check must verify the user's Node.js version."
                ),
                "file": "SECURITY.md",
                "cve": "CVE-2026-21636",
                "reason": "Runtime sandboxing relies on a Node.js feature that was bypassable before v22.12.0",
                "references": ["https://nvd.nist.gov/vuln/detail/CVE-2026-21636"],
            })

    def _check_ghsa_lobster_path_injection(self):
        """
        GHSA-4mhr-g7xj-cg8j: Lobster Extension arbitrary exec via path injection.

        Why: The Lobster extension allowed arbitrary code execution through
        lobsterPath and cwd parameter injection. Fixed in PR #5335.
        Demonstrates that extension path parameters are a real, exploited
        attack vector. Check if the vulnerable pattern exists.
        """
        lobster_files = list(self.repo_path.rglob("*lobster*"))
        for fpath in lobster_files:
            if fpath.is_file() and fpath.suffix in {".ts", ".js", ".json"}:
                try:
                    content = fpath.read_text(encoding="utf-8", errors="ignore")
                except OSError:
                    continue
                rel = str(fpath.relative_to(self.repo_path))
                if re.search(r"lobsterPath|cwd.*lobster", content, re.IGNORECASE):
                    self.findings.append({
                        "type": "vulnerability",
                        "category": "code_execution",
                        "severity": "high",
                        "title": "GHSA-4mhr-g7xj-cg8j: Lobster path injection",
                        "description": (
                            f"Lobster extension path parameter in {rel}. "
                            "GHSA-4mhr-g7xj-cg8j documented arbitrary code execution "
                            "via lobsterPath/cwd injection (fixed in PR #5335)."
                        ),
                        "file": rel,
                        "reason": "Extension path parameters were exploited for arbitrary code execution in production",
                        "references": ["https://github.com/advisories/GHSA-4mhr-g7xj-cg8j"],
                    })

    def _check_npm_lifecycle_scripts(self):
        """
        Check for npm lifecycle script abuse in skill package.json files.

        Why: Skills with their own package.json can execute arbitrary code
        during npm install via preinstall/postinstall scripts. OpenClaw's
        root package.json uses pnpm.onlyBuiltDependencies to whitelist
        which packages can run build scripts, showing awareness of this
        attack vector. MITRE ATT&CK T1195.002 (Supply Chain Compromise).
        """
        # Check skill directories for package.json with lifecycle scripts
        skills_dirs = [
            self.repo_path / "skills",
            self.repo_path / "extensions",
            self.repo_path / "plugins",
        ]
        import json
        for skills_dir in skills_dirs:
            if not skills_dir.exists():
                continue
            for pkg_path in skills_dir.rglob("package.json"):
                try:
                    data = json.loads(pkg_path.read_text(encoding="utf-8", errors="ignore"))
                except (json.JSONDecodeError, OSError):
                    continue

                scripts = data.get("scripts", {})
                dangerous_hooks = ["preinstall", "postinstall", "prepare", "prepublish"]
                for hook in dangerous_hooks:
                    if hook in scripts:
                        rel = str(pkg_path.relative_to(self.repo_path))
                        script_content = scripts[hook]
                        # Flag if script downloads or executes external code
                        is_dangerous = any(
                            kw in script_content.lower()
                            for kw in ["curl", "wget", "node -e", "bash", "sh ", "exec", "eval"]
                        )
                        severity = "critical" if is_dangerous else "medium"
                        self.findings.append({
                            "type": "vulnerability",
                            "category": "supply_chain",
                            "severity": severity,
                            "title": f"npm {hook} script in {rel}",
                            "description": (
                                f"Lifecycle script '{hook}': {script_content[:100]}. "
                                "npm lifecycle scripts execute automatically during install "
                                "and can run arbitrary code on the user's machine."
                            ),
                            "file": rel,
                            "reason": "npm lifecycle scripts are a documented supply chain attack vector (MITRE ATT&CK T1195.002)",
                            "references": ["https://attack.mitre.org/techniques/T1195/002/"],
                        })
